<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Titillium+Web:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<script
src="https://code.jquery.com/jquery-2.2.4.min.js"
integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="
crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
<link href="./css/shared.css" rel="stylesheet">
<link href="./css/combat.css" rel="stylesheet">
<link href="./css/profile.css" rel="stylesheet">
<link href="./css/order.css" rel="stylesheet">
<link href="./css/animations.css" rel="stylesheet">
<script src="./party.js"></script>
<script src="./input.js"></script>
<script src="./lib.js"></script>

<script>
  const q = getUrlVars();
  const data = input[q.data];
  const seedRand = new Math.seedrandom(JSON.stringify(data.moves));
  let interval = null;
  let ticks = 0;
  const combat = {
    turn: 0,
    allyIndex: 0,
    enemyIndex: 0,
    allyInputs: shuffle(data.moves),
    enemyInputs: shuffle(data.enemies),
    enemyDeck: shuffle(JSON.parse(JSON.stringify(data.actionDistribution))),
    done: false,
  };
  let queue = [];

  function unitInit(unit) {
    unit.chp = getStat('mhp', unit);
    unit.effects = [];
  }

  function nextEnemyAction() {
    if (combat.enemyDeck.length === 0) {
      combat.enemyDeck = shuffle(JSON.parse(JSON.stringify(data.actionDistribution)));
    }
    return combat.enemyDeck.pop();
  }

  function nextEnemy() {
    let fullCount = combat.enemyInputs.length + combat.enemyIndex;
    for (combat.enemyIndex; combat.enemyIndex < fullCount; combat.enemyIndex++) {
      const unit = combat.enemyInputs[combat.enemyIndex % combat.enemyInputs.length];
      if (unit.effects.indexOf('down') < 0) {
        return unit; 
      }
    }
    return false;
  }

  function findAlly(name) {
    for (let i = 0; i < party.members.length; i++) {
      if (party.members[i].name.toUpperCase() === name.toUpperCase()) {
        return party.members[i];
      }
    }
  }

  function findEnemy(name) {
    for (let i = 0; i < data.enemies.length; i++) {
      if (data.enemies[i].name.toUpperCase() === name.toUpperCase()) {
        return data.enemies[i];
      }
    }
  }

  function findLowestHPTeammate(unit) {
    let low = unit;
    const teamList = getTeamList(unit);
    for (let i = 0; i < teamList.length; i++) {
      lowHpPercent = unit.chp / getStat('mhp', unit);
      uHpPercent = teamList[i].chp / getStat('mhp', teamList[i]);
      if (uHpPercent < lowHpPercent) {
        low = teamList[i];
      }
    }
    return low;
  }

  function getTeamList(unit) {
    let list = data.enemies;
    if (findAlly(unit.name)) {
      list = party.members;
    }
    return list;
  }

  function setStatus(unit, status) {
    if (unit.effects.indexOf('down') > -1) {
      return;
    }
    const index = unit.effects.indexOf(status);
    if (status === 'disadvantage') {
      if (cancelStatus(unit, 'advantage')) {
        return;
      }
    }
    else if (status === 'advantage') {
      if (cancelStatus(unit, 'disadvantage')) {
        return;
      }
    }
    if (index < 0) {
      unit.effects.push(status);
    }
  }

  function cancelStatus(unit, status) {
    const index = unit.effects.indexOf(status);
    if (index >= 0) {
      unit.effects.splice(index, 1);
      return true;
    }
    return false;
  }

  function setTeamStatus(unit, status) {
    const list = getTeamList(unit);
    for (let i = 0; i < list.length; i++) {
      setStatus(list[i], status);        
    }
  }

  function drawRound(round) {
    let output = '';
    output += `
      <div class="round">
        <div class="skew">
          <div class="name"><span>${round.user}</span></div>
          <div class="turns">`;
    for (let i = 0; i < round.actions.length; i++) {
      let split = round.actions[i].split(':');
      output += `<div class="turn"><span>${split[0]} (${split[1]})</span></div>`;
    }
    output += ` 
          </div>
        </div>
      </div>
    `;
    return output;
  }

  function init() {
    let link = data.music.split('|');
    $('#order').before(`<div class="line music"><span class="inner"><span class="title">â™ª ${link[0]}</span><a href="${link[1]}" target="_blank"><img src="./images/play.svg"></a></span></div>`);

    for (let i = 0; i < combat.allyInputs.length; i++) {
      $('#order').append(drawRound(combat.allyInputs[i]));
    }
    updateOrder(combat.turn % combat.allyInputs.length, combat.allyIndex);
    
    for (let i = 0; i < party.members.length; i++) {
      unitInit(party.members[i]);
      $('#party-profiles').append(drawProfile(party.members[i], true));
    }  
    for (let i = 0; i < data.enemies.length; i++) {
      unitInit(data.enemies[i]);
      $('#enemy-profiles').append(drawProfile(data.enemies[i], true));
    }
  }

  function tick() {
    for (let i = 0; i < queue.length; i++) {
      if (queue[i].done) {
        continue;
      }
      if (!queue[i].delay || ticks >= queue[i].delay) {
        queue[i].done = true;
        switch(queue[i].type) {
          case 'animate':
            addEffect(queue[i].unit, `a-${queue[i].animation}`);
            break;
          case 'showAction':
            // $('#tiles').append(drawTile(queue[i].name, queue[i].success, queue[i].rolls));
            break;
          case 'textDrop':
            $(`.unit-${queue[i].unit.name.safeCSS()}`).prepend(`<div class="drop-text">${queue[i].text}</div>`);
            updateUnitProfile(queue[i].unit);
            break;
          case 'textPop':
            $(`.unit-${queue[i].unit.name.safeCSS()}`).prepend(`<div class="pop-text">${queue[i].text}</div>`);
            updateUnitProfile(queue[i].unit);
            break;
          case 'revealRolls':
            $('.dice').removeClass('hidden');
            break;
          case 'finish':
            $('.tile').remove();
            $('.profile').removeClass('a-forward');
            $('.profile').removeClass('a-attack');
            $('.profile').removeClass('a-defend');
            $('.profile').removeClass('a-special');
            $('.profile').removeClass('a-assist');
            $('.drop-text').remove();
            $('.pop-text').remove();
            updateAllUnitProfiles();
            clearInterval(interval);
            ticks = -1;
            queue = [];
            startTurn();
            break;
          default:
            console.log(queue[i].type);
            break;
        }
      }
    }
    ticks++;
  }

  function removeEffect(unit, effect) {
    $unit = $(`.unit-${unit.name.safeCSS()}`);
    $unit.removeClass(effect);
  }

  function addEffect(unit, effect) {
    $unit = $(`.unit-${unit.name.safeCSS()}`);
    $new = $unit.clone(true);
    $unit.before($new);
    $unit.remove();
    $new.addClass(effect);
  }

  function log(message) {
    $('#log').prepend(`<div>${message}</div>`);
  }

  function startTurn() {
    if (queue.length > 0 || combat.done) {
      return;
    }
    const participantIndex = combat.turn % combat.allyInputs.length;
    const playerTurn = splitCommand(combat.allyInputs[participantIndex].actions[combat.allyIndex]);
    updateOrder(participantIndex, combat.allyIndex);
    playerTurn.unit = findAlly(playerTurn.unitName);
    playerTurn.unit.xp += 5 * data.xpMultiplier;
    const enemy = nextEnemy();
    queue.push({type: 'animate', unit: playerTurn.unit, animation: 'forward'});
    queue.push({type: 'animate', unit: enemy, animation: 'forward'});
    if (!enemy) {
      queue.push({type: 'victory'});
      combat.done = true;
      clearInterval(interval);
      return;
    }
    const enemyTurn = {action: nextEnemyAction(), unit: enemy};
    combat.allyIndex++;
    if (combat.allyIndex === combat.allyInputs[participantIndex].actions.length) {
      combat.turn++;
      combat.allyIndex = 0;
    }
    combat.enemyIndex++;
    if (combat.enemyIndex >= combat.enemyInputs.length) {
      combat.enemyIndex = 0;
    }

    compareMap()[playerTurn.action][enemyTurn.action](playerTurn.unit, enemyTurn.unit);
    queue.push({type: 'finish', delay: 4});
    interval = setInterval(tick, 500);
  }

  function compareMessage(aName, aAction, aSuccesses, aStat, bName, bAction, bSuccesses, bStat) {
    queue.push({type: 'showAction', delay: 0, name: `${aName}'s ${aAction}`, success: aSuccesses, rolls: aStat});
    queue.push({type: 'showAction', delay: 0, name: `${bName}'s ${bAction}`, success: bSuccesses, rolls: bStat});
    log(`${aName}'s ${aAction} (${drawSuccesses(aSuccesses, aStat)}) vs ${bName}'s ${bAction} (${drawSuccesses(bSuccesses, bStat)})`);
  }

  function drawSuccesses(number, total) {
    let output = '';
    for (let i = 0; i < total; i++) {
      if (i < number) {
        output += '+';
      }
      else {
        output += '-';
      }
    }
    return output;
  }

  function drawTile(name, number, total) {
    let output = `
      <div class="tile">
        <div class="text">${name}</div>
        <div class="successes">`;
    for (let i = 0; i < total; i++) {
      if (i < number) {
        output += '<div class="dice success">+</div>';
      }
      else {
        output += '<div class="dice fail">-</div>';
      }
    }
    output += `
        </div>
      </div>
    `;    
    return output;
  }

  function compareMap() {
    const map = [];
    map['attack'] = [];
    map['defend'] = [];
    map['special'] = [];
    map['assist'] = [];
    map['attack']['attack']  = function(a, b)  { compareAttackAttack(a, b); };
    map['attack']['defend']  = function(a, b)  { compareAttackDefend(a, b); };
    map['attack']['special'] = function(a, b)  { compareAttackSpecial(a, b); };
    map['attack']['assist']  = function(a, b)  { compareAttackAssist(a, b); };
    map['defend']['attack']  = function(a, b)  { compareAttackDefend(b, a); };
    map['defend']['defend']  = function(a, b)  { compareDefendDefend(a, b); };
    map['defend']['special'] = function(a, b)  { compareDefendSpecial(a, b); };
    map['defend']['assist']  = function(a, b)  { compareDefendAssist(a, b); };
    map['special']['attack']  = function(a, b)  { compareAttackSpecial(b, a); };
    map['special']['defend']  = function(a, b)  { compareDefendSpecial(b, a); };
    map['special']['special'] = function(a, b)  { compareSpecialSpecial(a, b); };
    map['special']['assist']  = function(a, b)  { compareSpecialAssist(a, b); };
    map['assist']['attack']  = function(a, b)  { compareAttackAssist(b, a); };
    map['assist']['defend']  = function(a, b)  { compareDefendAssist(b, a); };
    map['assist']['special'] = function(a, b)  { compareSpecialAssist(b, a); };
    map['assist']['assist']  = function(a, b)  { compareAssistAssist(a, b) };
    return map;
  }

  function compareAttackAttack(a, b) {
    let aStat = getStat('attack', a);
    let bStat = getStat('attack', b);
    consumeAdvantage(a, b);
    let aSuccesses = getSuccesses(aStat);
    let bSuccesses = getSuccesses(bStat);
    compareMessage(a.name, 'attack', aSuccesses, aStat, b.name, 'attack', bSuccesses, bStat);
    queue.push({type: 'animate', delay: 1, unit: a, animation: 'attack'});
    queue.push({type: 'animate', delay: 1, unit: b, animation: 'attack'});
    if (aSuccesses > 0) {
      takeDamage(b, aSuccesses);
    }
    else {
      evadeDamage(b);
    }
    if (bSuccesses > 0) {
      takeDamage(a, bSuccesses);
    }
    else {
      evadeDamage(a);
    }
  }

  function compareAttackDefend(a, b) {
    let aStat = getStat('attack', a);
    let bStat = getStat('defend', b);
    consumeAdvantage(a, b);
    let aSuccesses = getSuccesses(aStat);
    let bSuccesses = getSuccesses(bStat);
    compareMessage(a.name, 'attack', aSuccesses, aStat, b.name, 'defend', bSuccesses, bStat);
    queue.push({type: 'animate', delay: 1, unit: a, animation: 'attack'});
    queue.push({type: 'animate', delay: 1, unit: b, animation: 'defend'});
    if (aSuccesses > bSuccesses) {
      takeDamage(b, aSuccesses - bSuccesses);
    }
    else if (bSuccesses > aSuccesses) {
      healDamage(b, bSuccesses - aSuccesses);
    }
    else {
      evadeDamage(b);
    }
  }

  function compareAttackSpecial(a, b) {
    let aStat = getStat('attack', a);
    let bStat = getStat('special', b);
    consumeAdvantage(a, b);
    let aSuccesses = getSuccesses(aStat);
    let bSuccesses = getSuccesses(bStat);
    compareMessage(a.name, 'attack', aSuccesses, aStat, b.name, 'special', bSuccesses, bStat);
    queue.push({type: 'animate', delay: 1, unit: a, animation: 'attack'});
    queue.push({type: 'animate', delay: 1, unit: b, animation: 'special'});
    interruptSpecial(a, b);
    if (aSuccesses > 0) {
      takeDamage(b, aSuccesses);
    }
  }

  function compareAttackAssist(a, b) {
    let aStat = getStat('attack', a);
    let bStat = getStat('assist', b);
    consumeAdvantage(a, b);
    let aSuccesses = getSuccesses(aStat);
    let bSuccesses = getSuccesses(bStat);
    compareMessage(a.name, 'attack', aSuccesses, aStat, b.name, 'assist', bSuccesses, bStat);
    queue.push({type: 'animate', delay: 1, unit: a, animation: 'attack'});
    queue.push({type: 'animate', delay: 1, unit: b, animation: 'assist'});
    if (aSuccesses > bSuccesses) {
      takeDamage(b, aSuccesses - bSuccesses);
    }
    else if (bSuccesses > aSuccesses + 1) {
      gainAdvantage(b);
      gainDisadvantage(a);
    }
    else if (bSuccesses > aSuccesses) {
      gainDisadvantage(a);
    }
    else {
      evadeDamage(b);
    }
  }

  function compareDefendDefend(a, b) {
    let aStat = getStat('defend', a);
    let bStat = getStat('defend', b);
    consumeAdvantage(a, b);
    let aSuccesses = getSuccesses(aStat) - 3;
    let bSuccesses = getSuccesses(bStat) - 3;
    compareMessage(a.name, 'defend', aSuccesses, aStat, b.name, 'defend', bSuccesses, bStat);
    queue.push({type: 'animate', delay: 1, unit: a, animation: 'defend'});
    queue.push({type: 'animate', delay: 1, unit: b, animation: 'defend'});
    if (aSuccesses > 0) {
      healDamage(a, aSuccesses);
    }
    else {
      healFail(a);
    }
    if (bSuccesses > 0) {
      healDamage(b, bSuccesses);
    }
    else {
      healFail(b);
    }
  }

  function compareDefendSpecial(a, b) {
    let aStat = getStat('defend', a);
    let bStat = getStat('special', b);
    consumeAdvantage(a, b);
    let aSuccesses = getSuccesses(aStat);
    let bSuccesses = getSuccesses(bStat);
    compareMessage(a.name, 'defend', aSuccesses, aStat, b.name, 'special', bSuccesses, bStat);
    queue.push({type: 'animate', delay: 1, unit: a, animation: 'defend'});
    queue.push({type: 'animate', delay: 1, unit: b, animation: 'special'});
    pierceDefense(b, a);
    if (bSuccesses > 0) {
      takeDamage(a, bSuccesses);
    }
    else {
      evadeDamage(a);
    }
  }

  function compareDefendAssist(a, b) {
    let aStat = getStat('defend', a);
    let bStat = getStat('assist', b);
    consumeAdvantage(a, b);
    let aSuccesses = getSuccesses(aStat) - 3;
    let bSuccesses = getSuccesses(bStat) - 3;
    compareMessage(a.name, 'defend', aSuccesses, aStat, b.name, 'assist', bSuccesses, bStat);
    queue.push({type: 'animate', delay: 1, unit: a, animation: 'defend'});
    queue.push({type: 'animate', delay: 1, unit: b, animation: 'assist'});
    if (aSuccesses > 0) {
      healDamage(a, aSuccesses);
    }
    else {
      healFail(a);
    }
    if (bSuccesses > 1) {
      gainAdvantage(b);
      gainDisadvantage(a);
    }
    else if (bSuccesses > 0) {
      gainDisadvantage(a);
    }
  }

  function compareSpecialSpecial(a, b) {
    let aStat = getStat('special', a);
    let bStat = getStat('special', b);
    consumeAdvantage(a, b);
    let aSuccesses = getSuccesses(aStat);
    let bSuccesses = getSuccesses(bStat);
    compareMessage(a.name, 'special', aSuccesses, aStat, b.name, 'special', bSuccesses, bStat);
    queue.push({type: 'animate', delay: 1, unit: a, animation: 'special'});
    queue.push({type: 'animate', delay: 1, unit: b, animation: 'special'});
    if (aSuccesses > bSuccesses) {
      takeDamage(b, aSuccesses - bSuccesses);
    }
    else if (bSuccesses > aSuccesses) {
      takeDamage(a, bSuccesses - aSuccesses);
    }
    else {
      specialCancel();
    }
  }

  function compareSpecialAssist(a, b) {
    let aStat = getStat('special', a);
    let bStat = getStat('assist', b);
    consumeAdvantage(a, b);
    let aSuccesses = getSuccesses(aStat);
    let bSuccesses = getSuccesses(bStat) - 3;
    compareMessage(a.name, 'special', aSuccesses, aStat, b.name, 'assist', bSuccesses, bStat);
    queue.push({type: 'animate', delay: 1, unit: a, animation: 'special'});
    queue.push({type: 'animate', delay: 1, unit: b, animation: 'assist'});
    if (aSuccesses > 0) {
      takeDamage(b, aSuccesses);
    }
    else {
      evadeDamage(b);
    }
    if (bSuccesses > 1) {
      gainAdvantage(b);
      gainDisadvantage(a);
    }
    else if (bSuccesses > 0) {
      gainDisadvantage(a);
    }
  }

  function compareAssistAssist(a, b) {
    let aStat = getStat('special', a);
    let bStat = getStat('assist', b);
    consumeAdvantage(a, b);
    let aSuccesses = getSuccesses(aStat);
    let bSuccesses = getSuccesses(bStat);
    compareMessage(a.name, 'assist', aSuccesses, aStat, b.name, 'assist', bSuccesses, bStat);
    queue.push({type: 'animate', delay: 1, unit: a, animation: 'assist'});
    queue.push({type: 'animate', delay: 1, unit: b, animation: 'assist'});

    if (aSuccesses > bSuccesses + 1) {
      gainAdvantage(a);
      gainDisadvantage(b);
    }
    else if (aSuccesses > bSuccesses) {
      gainDisadvantage(b);
    }
    else if (bSuccesses > aSuccesses + 1) {
      gainAdvantage(b);
      gainDisadvantage(a);
    }
    else if (bSuccesses > aSuccesses) {
      gainDisadvantage(a);
    }
    else {
      noAdvantage();
    }
  }

  function consumeAdvantage(a, b) {
    cancelStatus(a, 'advantage');
    cancelStatus(a, 'disadvantage');
    cancelStatus(b, 'advantage');
    cancelStatus(b, 'disadvantage');
  }

  function takeDamage(unit, value) {
    log(`${unit.name} took ${value} damage.`);
    unit.chp -= value;
    if (unit.chp <= 0) {
      unit.chp = 0;
    }
    queue.push({type: 'textDrop', delay: 2, unit, text: `-${value} HP`});
    if (unit.chp === 0) {
      log(`${unit.name} is downed!`);
      setStatus(unit, 'down');
    }
  }

  function healFail(unit) {
    log(`${unit.name} failed to heal any damage.`);
    queue.push({type: 'textPop', delay: 2, unit, text: `+0 HP`});
  }

  function healDamage(unit, value) {
    const target = findLowestHPTeammate(unit);
    if (target.chp < getStat('mhp', target)) {
      if (unit === target) {
        log(`${unit.name} healed ${value} damage.`);
        queue.push({type: 'textPop', delay: 2, unit: target, text: `+${value} HP`});
      }
      else {
        log(`${unit.name} healed ${target.name} of ${value} damage.`);
        queue.push({type: 'textPop', delay: 2, unit: target, text: `+${value} HP`});
      }
      target.chp += value;
      if (target.chp > getStat('mhp', target)) {
        target.chp = getStat('mhp', target);
      }
    }
    else {
      log(`${target.name}'s hp is full.`);
      queue.push({type: 'textPop', delay: 2, unit: target, text: `+0 HP`});
    }
  }

  function evadeDamage(unit) {
    log(`${unit.name} evaded.`);
    queue.push({type: 'textPop', delay: 2, unit, text: `EVADE`});
  }

  function interruptSpecial(a, b) {
    log(`${a.name} interrupted ${b.name}'s special!`);
  }

  function pierceDefense(a, b) {
    log(`${a.name} pierced ${b.name}'s defense!`);
  }

  function specialCancel() {
    log('The specials cancelled each other out!');
  }

  function noAdvantage() {
    log('Neither side gained any advantage.');
  }

  function gainAdvantage(unit) {
    log(`${unit.name}'s allies gain the advantage!`);
    setTeamStatus(unit, 'advantage');
  }

  function gainDisadvantage(unit) {
    log(`${unit.name}'s allies are disadvantaged!`);
    setTeamStatus(unit, 'disadvantage');
  }

  function updateAllUnitProfiles() {
    for (let i = 0; i < party.members.length; i++) {
      updateUnitProfile(party.members[i]);
    }  
    for (let i = 0; i < data.enemies.length; i++) {
      updateUnitProfile(data.enemies[i]);
    }  
  }

  function updateUnitProfile(unit) {
    // HP
    $unit = $(`.profile.unit-${unit.name.safeCSS()}`);
    $unit.find(`.meter.hp .curmax .current`).html(unit.chp);
    $unit.find(`.meter.hp .bar .inner`).css('width', unit.chp / getStat('mhp', unit) * 100 + '%');

    // XP
    $unit.find(`.meter.xp .curmax .current`).html(unit.xp);
    $unit.find(`.meter.xp .bar .inner`).css('width', Math.min(unit.xp / (level(unit) * 5), 1) * 100 + '%');

    // Status
    if ($unit.find('.status').length > 0) {
      $unit.find('.status').replaceWith(drawStatus(unit));
    }
    else {
      $unit.append(drawStatus(unit));
    }

    // Stats
    $unit.find('.stat.attack').replaceWith(drawStat('Attack', unit.attack, getBonus('attack', unit), 8));
    $unit.find('.stat.special').replaceWith(drawStat('Special', unit.special, getBonus('special', unit), 8));
    $unit.find('.stat.assist').replaceWith(drawStat('Assist', unit.assist, getBonus('assist', unit), 8));
    $unit.find('.stat.defend').replaceWith(drawStat('Defend', unit.defend, getBonus('defend', unit), 8));
  }

  function updateOrder(player, unit) {
    $('#order .active').removeClass('active');
    $(`#order .round:nth-child(${player+1})`).addClass('active');
    $(`#order .round:nth-child(${player+1}) .turn:nth-child(${unit+1})`).addClass('active');
  }
  
</script>
<title>V-RPG | Combat</title>
</head>
<body>

<div class="container">
  <div id="tiles"></div>

  <div class="row">
    <div id="combat" class="col col-sm-8 row">
      <div id="party-profiles" class="col col-6"></div>
      <div id="enemy-profiles" class="col col-6"></div>  
    </div>
    <div class="col col-sm-4">
      <div id="order"></div>
      <div id="log"></div>
    </div>
  </div>
</div>
<script>
  init();
  // startTurn();
</script>
</body>
</html>